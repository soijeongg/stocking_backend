<img src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/9a26918c-3c08-4bfa-98cd-afe2f31ab513"/>

## 📈 서비스 소개

<h3>10만건의 동시 주문도 처리 가능한 모의 주식 투자 서비스 </h3>
<b>10만건의 부하 테스트 결과: 평균 응답 시간 100ms, TPS 894.2/s</b>
<br>
<br>
<img src="https://github.com/jovid18/problem_solving/assets/143411145/20cf28ac-11a2-441c-941b-2f3f5ea74246">
<br>
<br>
<b> 10만건의 동시 주문시에도 체결이 진행되는 모습</b>
<br>
<br>
<img src="https://github.com/jovid18/problem_solving/assets/143411145/60f2dec7-2d18-4637-bdf8-f8834701ab88">

## 🎯 서비스의 목표

- 처음 해보는 유저들도 쉽게 참여가 가능한 모의 주식 투자 서비스
- 대용량 트래픽에서도 안전하게 체결이 진행되는 서버
- 주문의 순서가 보장되는 메시지 체결(동시성 제어)
- 실시간 모니터링으로 서버의 상태 확인 및 서버 이상 시 슬랙으로 알람

## 🖇️ 프로젝트 링크

<table width="80%;">
  <tr align="center">
    <td><strong>구분</strong></td>
    <td><strong>링크</strong></td>
  </tr>
  <tr align="center">
    <td><img src="https://github.com/jovid18/problem_solving/assets/143411145/2d627fc6-71ea-4854-a19e-5c2c7d1f1cc7" alt="스톡킹 로고" style="width: 23px;"></td>
    <td><a target="_blank" rel="noopener noreferrer nofollow" href="https://www.nodejstrello.site/">STOCKING</a></td>
  </tr>
  <tr align="center">
    <td><img src="https://github.com/norwegianwood97/project_trello_backend_personal/blob/dev/icons/FeGithub.png" alt="FE Github 아이콘" style="width: 23px;"></td>
    <td><a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/hh99-stock/Stocking_Frontend">FE Github</a></td>
  </tr>
  <tr align="center">
    <td><img src="https://github.com/norwegianwood97/project_trello_backend_personal/blob/dev/icons/BeGithub.png" alt="BE Github 아이콘" style="width: 23px;"></td>
    <td><a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/hh99-stock/Stocking_Backend">BE Github</td>
  </tr>
  <tr align="center">
    <td><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e9/Notion-logo.svg/1024px-Notion-logo.svg.png" alt="노션 아이콘" style="width: 23px;"></td>
    <td><a target="_blank" rel="noopener noreferrer nofollow" href="https://airy-ounce-83b.notion.site/STOCKING-BROCHURE-ae607d3fdfbb4814bd7ca68939320177?pvs=4">브로슈어</a></td>
  </tr>
        <tr align="center">
    <td><img src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/af5c5a9b-f745-4058-99fd-a0017a322ce5" alt="유튜브 아이콘" style="width: 23px;"></td>
    <td><a target="_blank" rel="noopener noreferrer nofollow" href="https://youtu.be/6u55gFAiZ8Y?si=anD9tCSg3OBgOWlE">발표 영상</a></td>
  </tr>
        <tr align="center">
    <td><img src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/af5c5a9b-f745-4058-99fd-a0017a322ce5" alt="유튜브 아이콘" style="width: 23px;"></td>
    <td><a target="_blank" rel="noopener noreferrer nofollow" href="https://youtu.be/UjeFwfzWx_E?si=R-8xwxMSPW_Fwks9">소개 영상</a></td>
  </tr>
</table>

## 📚기술 스택 정리

<div align=center>

  <img src="https://img.shields.io/badge/node.js-5FA04E?style=for-the-badge&logo=node.js&logoColor=white"> 
  <img src="https://img.shields.io/badge/express-000000?style=for-the-badge&logo=express&logoColor=white"> 
  <img src="https://img.shields.io/badge/websocket-000000?style=for-the-badge&logo=websocket&logoColor=white"> 
  <img src="https://img.shields.io/badge/jest-C21325?style=for-the-badge&logo=jest&logoColor=white">
  <img src="https://img.shields.io/badge/passport-34E27A?style=for-the-badge&logo=passport&logoColor=white">
  
  <br>
  <img src="https://img.shields.io/badge/html5-E34F26?style=for-the-badge&logo=html5&logoColor=white"> 
  <img src="https://img.shields.io/badge/css-1572B6?style=for-the-badge&logo=css3&logoColor=white"> 
  <img src="https://img.shields.io/badge/javascript-F7DF1E?style=for-the-badge&logo=javascript&logoColor=black"> 
  <img src="https://img.shields.io/badge/react-61DAFB?style=for-the-badge&logo=react&logoColor=white">
  <img src="https://img.shields.io/badge/Axios-5A29E4?style=for-the-badge&logo=axios&logoColor=white">  
  <img src="https://img.shields.io/badge/Echarts-AA344D?style=for-the-badge&logo=apacheecharts&logoColor=white">   
  <img src="https://img.shields.io/badge/vercel-000000?style=for-the-badge&logo=vercel&logoColor=white">
  <br>

  <img src="https://img.shields.io/badge/amazonaws-232F3E?style=for-the-badge&logo=amazonaws&logoColor=white"> 
  <img src="https://img.shields.io/badge/Ubuntu-E95420?style=for-the-badge&logo=ubuntu&logoColor=white"> 
  <img src="https://img.shields.io/badge/AWS EC2-FF9900?style=for-the-badge&logo=amazonec2&logoColor=white">  
  <img src="https://img.shields.io/badge/AWS Route 53-8C4FFF?style=for-the-badge&logo=amazonroute53&logoColor=white">   
  <img src="https://img.shields.io/badge/AWS Alb-FF9900?style=for-the-badge&logo=awselasticloadbalancing&logoColor=white">  
  <img src="https://img.shields.io/badge/AWS ECR-FF9900?style=for-the-badge&logo=awsecr&logoColor=white">   
  <img src="https://img.shields.io/badge/AWS ECS-FF9900?style=for-the-badge&logo=amazonecs&logoColor=white">   
  
  
  <br>
  
  
  <img src="https://img.shields.io/badge/AWS RDS-527FFF?style=for-the-badge&logo=amazonrds&logoColor=white"> 
  <img src="https://img.shields.io/badge/mysql-4479A1?style=for-the-badge&logo=mysql&logoColor=white"> 
  <img src="https://img.shields.io/badge/prisma-2D3748?style=for-the-badge&logo=prisma&logoColor=white"> 
  <img src="https://img.shields.io/badge/AWS elasticcache-2D3748?style=for-the-badge&logo=amazonelasticache&logoColor=white"> 
  <img src="https://img.shields.io/badge/redis-DC382D?style=for-the-badge&logo=redis&logoColor=white"> 
  <br>

  <img src="https://img.shields.io/badge/prettier-F7B93E?style=for-the-badge&logo=prettier&logoColor=white">
  <img src="https://img.shields.io/badge/eslint-4B32C3?style=for-the-badge&logo=prettier&logoColor=white">
  <img src="https://img.shields.io/badge/prometheus-E6522C?style=for-the-badge&logo=prometheus&logoColor=white"> 
  <img src="https://img.shields.io/badge/grafana-F46800?style=for-the-badge&logo=grafana&logoColor=white">
  <img src="https://img.shields.io/badge/kafka-231F20?style=for-the-badge&logo=apachekafka&logoColor=white">
  <img src="https://img.shields.io/badge/jmeter-D22128?style=for-the-badge&logo=apachejmeter&logoColor=white">
  <br>
  
  <img src="https://img.shields.io/badge/git-F05032?style=for-the-badge&logo=git&logoColor=white">
  <img src="https://img.shields.io/badge/github-181717?style=for-the-badge&logo=github&logoColor=white">
  <img src="https://img.shields.io/badge/github actions-2088FF?style=for-the-badge&logo=githubactions&logoColor=white">
  <img src="https://img.shields.io/badge/docker-2496ED?style=for-the-badge&logo=docker&logoColor=white">
  <img src="https://img.shields.io/badge/docker compose-2496ED?style=for-the-badge&logo=dockercomposer&logoColor=white">
  <img src="https://img.shields.io/badge/slack-4A154B?style=for-the-badge&logo=slack&logoColor=white">
  <img src="https://img.shields.io/badge/notion-000000?style=for-the-badge&logo=notion&logoColor=white">

</div>

## 🪶 주요 기능

<details>
    <summary>
        <b>📌로그인 & 회원가입 </b>
    </summary>
    <ul>
        <li>로컬 회원가입 가능 및 카카오, 네이버, 구글의 소셜 로그인 가능</li>
        <li>redis를 활용해 세션 저장</li>
        <li>중복로그인시 웹 소켓을 사용해 로그아웃 됩니다 라는 메세지 전송 후 세션 삭제</li>
        <img src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/664c5c5b-8ff1-48b9-a511-86773c7fbf1e">
    </ul>
</details>
<details>
    <summary>
        <b>📌게임 시스템 </b>
    </summary>
    <ul>
        <li>12분 마다 게임 시작 게임의 시작은 채팅에서 알려주며 각종 이벤트의 정보를 보여줌</li>
        <li>이벤트가 호재인지 악재인지에 따라 더미의 주문이 달라짐 → 보다 실감나는 모의 주식이 가능</li>
        <li>시장가/지정가, 매수/매도 주문의 생성 및 주문 정정, 삭제 가능</li>
        <li>종목별/ 매수/매도, 최신순/ 오래된순과 같이 원하는 조건으로 주문 조회 가능</li>
        <li>차트와 호가창을 이용해 시각적으로 주식의 흐름 파악가능</li>
        <li>게임이 진행되는 동안 가장 많은 수익률을 낸 사람이 우승</li>
        <img src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/7f9c4559-34af-41c0-9e24-c5a27114d844">
    </ul>
</details>
<details>
    <summary>
        <b>📌랭크 시스템 </b>
    </summary>
    <ul>
        <li>게임에서의 수익률에 따라 순위가 공지</li>
        <li>수익률에 따라 MMR 점수가 올라가고 MMR에 따라 티어가 변동</li>
        <img src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/583a6a0a-df96-44e5-99dd-9fed13c87f34">
    </ul>
</details>
<details>
    <summary>
        <b>📌채팅 시스템 </b>
    </summary>
    <ul>
        <li>메인페이지, 회사 페이지, 주문페이지에 채팅창 존재 </li>
        <li>각 사용자들의 채팅 뿐만이 아니라 게임의 시작과 종료, 각종 이벤트들이 수신됨</li>
        <li>체결 성공 및 실패 여부를 채팅으로 전달</li>
        <img src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/1e8ccfb4-bb3a-45bb-be75-bb953835742d">
    </ul>
</details>

## 🙋🏻 팀원 소개

| 역할 | 이름   | 담당  | Email                 | GitHub                                                |
| ---- | ------ | ----- | --------------------- | ----------------------------------------------------- |
| 팀장 | 정소이 | BE/FE | writer__soi@naver.com | [soijeongg](https://github.com/soijeongg)             |
| 팀원 | 조성현 | BE/FE | cshcho99@gmail.com    | [jovid18](https://github.com/jovid18)                 |
| 팀원 | 최준혁 | BE/FE | jhmhmami@naver.com    | [norwegianwood97](https://github.com/norwegianwood97) |
| 팀원 | 윤형식 | BE/FE | fly010905@gmail.com   | [nyeongsik13](https://github.com/nyeongsik13)         |

<details>
  <summary><h2>📜개발 기획 및 진행</h2></summary>
  <div markdown="1">
    <h2>✍🏻기획</h2>
    <img src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/f80575de-a987-4a24-8cef-5405c70b15aa" alt="todoist" width="12"> 
    <a href="https://www.notion.so/e03d91c506534ed0bee678b38897693d?pvs=21">사전 회의</a>
    <br>
    <br>
    <img src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/d1241914-e6d9-48a3-82a7-f0661122f96c" alt="todoist" width="12"> 
    <a href="https://www.notion.so/USER-FLOW-f05e4237ebbc466caf562657bffa636f?pvs=21">USER FLOW</a>
    <br>
    <br>
    <img src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/4a18aa54-10bb-48c5-a7d2-aa24564e9790" alt="todoist" width="12"> 
    <a href="https://www.notion.so/ERD-36505d0538544c70bbf570b400df1924?pvs=21">ERD</a>
    <br>
    <br>
    <img src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/78168792-72bb-424b-9595-e69fc29187a8" alt="todoist" width="12"> 
    <a href="https://www.notion.so/WIRE-FRAME-add1e787352e497fb2c1354bac01fcf3?pvs=21">WIRE FRAME</a>
    <br>
    <br>
    <img src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/7178a39b-156b-40b0-83db-e44400e0ec64" alt="todoist" width="12"> 
    <a href="https://www.notion.so/SEQUENCE-DIAGRAM-f0030d82b9c54344be114a44ca5393bc?pvs=21">SEQUENCE DIAGRAM</a>
    <br>
    <br>
    <img src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/9794bfb8-a7cc-4a7f-bb06-195fff7388f6" alt="todoist" width="12"> 
    <a href="https://www.notion.so/4511c7eec52844bc808dfebf78d9975a?pvs=21">서버 버전 관리</a>
    <h2>📓 진행</h2>
    <img src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/1fad7396-6385-4725-b94b-77af2aa1d0bf" alt="todoist" width="12"> 
    <a href="https://www.notion.so/TO-DO-LIST-f2120f8892f04a7d95a85837b1797e07?pvs=21">TO-DO LIST</a>
    <br>
    <br>
    <img src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/082fdcfa-a977-4dd1-9bce-a1556e50b4c3" alt="todoist" width="12"> 
    <a href="https://www.notion.so/312f4e5cf26b44a994e9157c89fedc41?pvs=21">프론트 페이지 정리</a>
    <br>
    <br>
    <img src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/17ed58bf-c8f5-44fb-ae8d-514626cbf1c8" alt="todoist" width="12"> 
    <a href="https://www.notion.so/API-fdbcb7bf1c0a429fb615ca6ae60cc27a?pvs=21">백엔드 API 정리</a>
    <br>
    <br>
    <img src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/1e9ca44b-a6a2-4f0b-b787-e1f1fc0a7c13" alt="todoist" width="12"> 
    <a href="https://www.notion.so/1d409d19ed1f4a7a9c0d62fecfd20429?pvs=21">스케쥴링 함수 정리</a>
    <br>
    <br>
    <img src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/0c4489f4-2500-4adf-b328-fd429cb03a2d" alt="todoist" width="12"> 
    <a href="https://www.notion.so/env-1d8a404a43cf4f878cd5fc2c8c7e78c3?pvs=21">.env 정리</a>
    <br>
    <br>
    <img src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/233b9442-84a5-466f-b223-4697cb2e3b6f" alt="todoist" width="12"> 
    <a href="https://www.notion.so/fbe3f9162b20464aa946f4455d8d2bae?pvs=21">메시지 큐 정리</a>
    <br>
    <br>
    <img src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/c26999ab-9301-42b1-8d8f-18b1c72da07c" alt="todoist" width="12"> 
    <a href="https://www.notion.so/8e77267be72846eb99ab9d3353e8984b?pvs=21">부하테스트&모니터링</a>
  </div>
</details>

## 🧭 서비스 아키텍쳐

![serivce](https://github.com/hh99-stock/Stocking_Backend/assets/143411145/c847e61a-0bc1-4dca-b496-7a953e68fc35)

<details>
    <summary>
        <h2> ✔️ 기술적 의사 결정 </h2>
    </summary>
    <table border="1">
        <thead>
            <tr>
                <th>사용 기술</th>
                <th>기술 설명</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>Node.JS</strong></td>
                <td>JavaScript를 이용하는 가장 대중적인 프레임워크인 Node.JS를 사용하기로 결정했습니다.</td>
            </tr>
            <tr>
                <td><strong>MySQL</strong></td>
                <td>MySQL은 사용자가 데이터베이스 솔루션을 무료로 개발하고 배포할 수 있으며 ACID 규약을 준수해 높은 신뢰성과 안정성을 보장하고, 또한 웹 애플리케이션에서 빠른 읽기와
                    쓰기 속도 등 많은 장점을 가져서 사용하였습니다.</td>
            </tr>
            <tr>
                <td><strong>Redis</strong></td>
                <td>Redis는 인메모리 데이터베이스를 사용하여 데이터 처리 속도가 디스크 기반 데이터베이스보다 훨씬 빠르기 때문에 리소스 소모와 DB 서버의 부하를 줄이기 위해 사용했습니다.
                    이를 통해 주문 처리 속도를 대폭 개선하고 전반적인 시스템 성능을 향상시킬 수 있었습니다.</td>
            </tr>
            <tr>
                <td><strong>Session</strong> vs JWT</td>
                <td>세션의 경우에는 모든 인증 정보를 세션에서 관리하기 때문에 보안 측면에서 유리하고, 만약 세션이 탈취가 되어도 서버에서 해당 세션을 무효화하면 되지만 토큰에는 정보가 다
                    들어있어서 해당 토큰을 무효화하더라도 정보 유출을 막을 수 없습니다. 이에 따라 보안성이 더 뛰어난 세션을 쓰기로 결정했습니다.</td>
            </tr>
            <tr>
                <td><strong>PRISMA</strong></td>
                <td>프리즈마는 간단한 구문을 사용해 데이터베이스와 상호작용하는 ORM이며 다양한 데이터베이스 드라이버를 지원하여 사용하였습니다.</td>
            </tr>
            <tr>
                <td><strong>ioredis</strong> vs redis</td>
                <td>ioredis 패키지는 redis 패키지에 비해 대규모 및 복잡한 환경에서 더 많은 기능과 유연성을 제공하여 채택하였습니다.</td>
            </tr>
            <tr>
                <td><strong>passport</strong></td>
                <td>Passport는 다양한 인증 전략을 지원하여 로컬 로그인 외에도 Google, Kakao 등 다양한 플랫폼의 인증을 활용할 수 있습니다. 또한 복잡한 인증 로직을 간단하게
                    구현할 수 있어 개발 편의성과 소셜 로그인 구현을 위해 사용하기로 결정했습니다.</td>
            </tr>
            <tr>
                <td><strong>Argon2</strong> vs bcrypt</td>
                <td>Argon2는 bcrypt 보다 최근에 개발되었고, 현재까지 개발된 암호화 함수 중 가장 강력한 보안성을 제공하여 Argon2를 채택하였습니다.</td>
            </tr>
            <tr>
                <td><strong>WebSocket</strong> vs socket.io</td>
                <td>Socket.io에 비해 상대적으로 경량화되어있는 WebSocket을 선택하여 메모리와 CPU의 사용을 줄였습니다.</td>
            </tr>
            <tr>
                <td><strong>Jest</strong></td>
                <td>Jest는 설정이 간편하고, 실행 속도가 빠르며 스냅샷 테스팅을 통해 변경사항을 쉽게 확인할 수 있습니다. 또한 단위 테스트와 통합 테스트에 적합한 다양한 도구를 제공하기
                    때문에 사용이 편리하여 테스트 패키지로 jest를 채택하였습니다.</td>
            </tr>
            <tr>
                <td><strong>Vercel</strong></td>
                <td>React 애플리케이션을 손쉽게 배포할 수 있는 최적화된 환경을 제공하며 GitHub와 같이 소스 코드 저장소와 통합을 통해 코드 커밋이 이러어질 때마다 자동으로 빌드와
                    배포가 실행되기에 배포 프로세스에 대한 관리 부담을 줄이고, 코드 변경 사항을 신속하게 적용할 수 있어 사용했습니다.</td>
            </tr>
            <tr>
                <td><strong>Github Actions</strong></td>
                <td>GitHub Actions는 사용이 쉽고 복잡한 절차 없이 GitHub과 원활하게 통합될 수 있는 장점이 있습니다. 또한, 배포 과정에 도움이 되는 다양한 템플릿을 제공하여
                    효율적인 워크플로우를 구축할 수 있어 배포에 Github Actions를 사용하였습니다.</td>
            </tr>
            <tr>
                <td><strong>prettier/eslint</strong></td>
                <td>각자 작성한 코드의 스타일을 일치시키기 위해 prettier를 사용하여 세미콜론, 줄 바꿈과 관련하여 자동으로 조정하고자 하였고, ESLint를 이용해 prettier의
                    스타일에 맞게 코드 스타일을 일치시켰습니다.</td>
            </tr>
            <tr>
                <td><strong>ALB</strong></td>
                <td>ALB를 사용함으로써 여러 서버에 걸쳐 트래픽을 효과적으로 분산시킬 수 있었습니다. 이는 각 서버의 과부하를 방지하고 서버간 트래픽이 고르게 분산되면서 각 서버의 부하가
                    경감됩니다. 결과적으로, 이는 각 서버에서 더 빠르고 효율적인 처리를 가능하게 하여 최종 사용자 경험을 크게 향상시킬 수 있어 사용하였습니다.</td>
            </tr>
            <tr>
                <td><strong>Docker</strong></td>
                <td>Docker는 컨테이너화 기술을 사용하여 애플리케이션의 실행 환경을 격리하므로, Amazon EC2 인스턴스 내에서 직접 서버를 배포하는 것과 비교해 더 높은 환경의
                    일관성과 이식성을 제공합니다. 또한 Docker를 사용하면 CD 과정에서 이미지를 빌드하고,이를 배포하는 과정이 일관되게 이루어지므로, 더 빠르고 효율적인 배포 프로세스를
                    구축할 수 있었습니다.</td>
            </tr>
            <tr>
                <td><strong>ECR</strong> vs Docker Hub</td>
                <td>CD를 통해 배포 프로세스를 자동화하는 과정에서 깃 액션을 통해 이미지를 기존에는 도커 허브에 올렸으나 보안이 우려되어 이미지 저장소를 AWS의 ECR로 변경하였습니다.
                </td>
            </tr>
            <tr>
                <td><strong>ECS</strong></td>
                <td>ECS는 손쉽게 ECR의 이미지를 이용하여 ECS 인스턴스를 생성해주는 컨테이너 오케스트레이션 서비스로 러닝커브가 낮고, 오토스케일링 및 무중단 배포가 지원되기 때문에
                    ECS를 채택하였습니다.</td>
            </tr>
            <tr>
                <td><strong>Kafka</strong> vs Redis-Streams</td>
                <td>사용자의 주문에 대해 순서를 지키며 처리하기 위해 메시지큐 통신을 선택하였습니다. 이에 따라 Kafka와 Redis-Streams의 사용을 고민하고 Kafka가 확장성이
                    높고 대규모 트래픽을 처리하는데 최적화 되어 있어 Kafka를 채택하여 사용했습니다.</td>
            </tr>
            <tr>
                <td><strong>Jmeter</strong></td>
                <td>Jmeter는 오픈소스이며, csv와 다양한 테스트 스크립트를 사용해 테스트 작업을 간소화 할 수 있는 장점을 가지고 있었습니다. 또한 많은 레퍼런스가 존재해 손쉽게 적용할
                    수 있었기 때문에 Jmeter를 체택해 부하 테스트에 사용했습니다.</td>
            </tr>
            <tr>
                <td><strong>node-exporter</strong></td>
                <td>node-exporter는 서버 수준에서 시스템의 상태를 수집합니다 node-exporter를 사용하면 직접 매트릭을 수집하는 코드를 쓰지 않고도 간편하게 시스템의 매트릭을
                    수집 할 수 있기 때문에 node-exporter를 사용했습니다.</td>
            </tr>
            <tr>
                <td><strong>Prometheus</strong></td>
                <td>프로메테우스는 오픈소스 모니터링 및 경고 도구로, 시스템과 서비스의 상태를 실시간으로 모니터링하는 데 사용했습니다. 프로메테우스는 시스템의 성능 지표를 실시간으로 수집하고
                    비침투적인 모니터링통해 서비스가 모니터링 과정에서 발생할 수 있는 성능 저하나 중단 없이 지속적으로 데이터 수집이 가능합니다. 이러한 장점 때문에 Prometheus을
                    선택하여 시스템과 서비스의 상태를 실시간으로 모니터링 하였습니다.</td>
            </tr>
            <tr>
                <td><strong>Grafana</strong></td>
                <td>Grafana는 오픈소스 데이터시각화 툴로써 다양한 그래프, 지오맵등을 사용하여 데이터를 시각화 하여 데이터를 더 직관적으로 이해 할 수 있다는 점과 슬랙이나 메일을 통해
                    사용자에게 알림을 보낼 수 있다는 점때문에 체택해 사용했습니다.</td>
            </tr>
        </tbody>
    </table>
</details>

## 🔎 성능 개선 결과

<details>
    <summary>
        <h2>📕 서버 버전별 요약</h2>
    </summary>
    <div markdown="1">
        <img src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/0a46cd28-c4a2-4955-a5e6-49723fe0becc">
    </div>
</details>
<details>
    <summary>
        <h2>📗 부하 테스트 및 모니터링 결과 </h2>
    </summary>
    유저수는 동일하게 100명으로 테스트하고, 본 서비스의 핵심인 주문 요청에 대한 부하를 검증
    <br>
    Jmeter를 이용하여 가상의 유저가 <b>1번의 회원가입→ 1번의 로그인→ n번의 주문 → 1번의 로그아웃을 요청하는 스파이크 테스트</b>를 진행
    <h3>100명의 유저가 100번의 주문 요청</h3>
    <img src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/8c533156-cfbc-4ae5-be95-ba1ac6aabfc8">
    <br>
    <h3>100명의 유저가 200번의 주문 요청</h3>
    <img src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/badb037b-be9f-4144-88ac-3703294f1a33">
    <br>
    <h3>100명의 유저가 500번의 주문 요청</h3>
    <img src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/d826e6c6-162d-4358-9b88-b5af24472f6b">
</details>

## 1️⃣ TPS 및 평균 응답 시간 개선

<b>🆙 성능 개선 결과</b>
<br>
- **TPS: 77.6/s→590.3/s (660.7% 증가), 평균응답시간: 1211.3ms→177ms (85.39% 감소)**
![change](https://github.com/hh99-stock/Stocking_Backend/assets/143411145/49449cdc-e6de-4daf-b1df-b62b2ce1b154)

## 2️⃣ 주문 처리 속도 개선

- STOCKING의 체결 로직: 주문 유효성 검증 ⇒ 주문 생성 및 삭제 ⇒ 주문 매칭 ⇒ 주문 체결
- Ver 3.0은 체결서버( MySQL, **주문 유효성 검증 ⇒ 주문 생성 및 삭제 ⇒ 주문 매칭 ⇒ 주문 체결**)
- Ver 4.0은 매칭서버( Redis, **주문 유효성 검증 ⇒ 주문 생성 및 삭제 ⇒ 주문 매칭**) , 체결 서버 (MySQL, **주문 체결**)
- 즉, ver 3.0의 체결 서버로부터 체결 과정의 일부를 Redis를 이용하는 매칭 서버를 분리하여 주문 처리 속도 개선

<b>🆙 성능 개선 결과</b>
<br> 
-  **단일 주문 처리 시간: 87.16ms→77.28ms (11.34% 감소), 1만건의 동시 주문 총 처리시간: 796s→601s (24.5% 감소)**

<b>✅ 단일 주문 처리 시간 비교</b>

![only one](https://github.com/hh99-stock/Stocking_Backend/assets/143411145/77821c9f-7b72-4d8e-9538-8b01f17a73d3)

<b>✅ 동시 주문 10000건의 총 처리 시간 비교 </b>

![100000](https://github.com/hh99-stock/Stocking_Backend/assets/143411145/9ffee6f9-c973-4e48-935c-018b2eb72d42)

<details>
    <summary>
        <h2>❗트러블 슈팅(성능 개선/대규모 트래픽 처리)</h2>
    </summary>
    <details>
        <summary>
            <h3>사용자에게 주문의 체결 결과를 응답으로 전달하여 대기시간이 너무 길어지는 문제 (ver 0.0)</h3>
        </summary>
        <ul>
            <li>문제 상황</li>
            <ul>
                <li>
                    기존 코드의 경우 주문 처리를 다한 뒤 그 결과를 사용자에게 응답하는 방식
                </li>
                <pre><code>
postOrder = async (req, res) => {
    const { userId } = res.locals.user;
    const orderData = req.body;
    if (orderData.price) {
        orderData.price = 10000 * Math.floor(+orderData.price / 10000);
    }
    try {
        const result = <b>await</b> this.orderService.createOrder(userId, orderData);
        return res.json({ message: result });
    } catch (error) {
        console.log(error.message);
        const { message } = error.message ? error : { message: '주문 생성 도중 문제가 발생했습니다.' };
        if (error.message) return res.status(400).json({ message });
    }
};
                    </code></pre>
                <li>
                    이로 인해 응답으로 인한 시간이 너무 걸림
                </li>
            </ul>
            <br>
            <li>해결 방법</li>
            <ul>
                <li>
                    주문 처리를 대기하지 않고, 사용자에게는 주문 접수에 대한 성공/실패 여부를 바로 전달
                </li>
                <li>
                    이후 주문 처리의 결과는 소켓 채팅창으로 공지
                </li>
            </ul>
        </ul>
    </details>
    <details>
        <summary>
            <h3>사용자가 불가능한 주문을 허용하여 불필요한 리소스 낭비 (ver 0.0 ⇒ ver 1.0)</h3>
        </summary>
        <ul>
            <li>문제 상황</li>
            <ul>
                <li>
                    가령 사용자가 현재 잔액이 1000만원이 있는 상황에서 현재가보다 낮은 가격으로 지정가 매수 100만원 주문을 20번 신청하더라도 이를 방지할 수 없었음
                </li>
                <li>
                    이로 인해, 체결과정에서 현재 사용자가 체결 당시 현금 또는 주식이 있는지 체크를 했어야 했고 이로 인해 불필요한 리소스가 낭비
                </li>
            </ul>
            <br>
            <li>해결 방법</li>
            <ul>
                <li>
                    사용자가 가용 금액, 가용 주식을 도입하여 아직 체결되지 않은 주문이라도 가용 금액/가용 주식이 감소하여 사용자의 현재 상황으로는 불가능한 주문을 방지
                </li>
                <li>
                    ERD에 tradableQuantity, tradableQuantity를 도입하고 그에 맞게 체결 함수를 ver 0.0에서 ver 1.0으로 변경
                </li>
                <br>
                <details>
                    <summary>체결함수 ver 0.0</summary>
                    <img
                        src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/1450b8ce-f091-4f79-a244-2d5ce7698f8f" />
                </details>
                <details>
                    <summary>체결함수 ver 1.0</summary>
                    <img
                        src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/cf14e102-381c-4ce7-b5e0-b5a160d63a17" />
                </details>
            </ul>
        </ul>
    </details>
    <details>
        <summary>
            <h3>메인 서버에서 API 통신과 소켓 통신 둘 다 담당하는 문제 (ver 1.0 ⇒ver 2.0)</h3>
        </summary>
        <ul>
            <li>문제 상황</li>
            <ul>
                <li>
                    메인 서버와 소켓 서버가 같은 역할을 겸함, 이는 여러 사용자가 접속해 있을 때 메인 서버의 부하를 키우게 됨
                </li>
            </ul>
            <br>
            <li>해결 방법</li>
            <ul>
                <li>
                    메인 서버로부터 소켓 서버를 분리하였고, ALB를 이용해 메인 서버로 가는 요청(/api*)과 소켓 서버로 가는 요청을 (/ws*) 경로 기반 라우팅 처리
                </li>
                <br>
                <details>
                    <summary>서버 버전 1.0</summary>
                    <img
                        src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/01422de2-3346-4cc7-bf40-fecb331eac9e" />
                </details>
                <details>
                    <summary>서버 버전 2.0</summary>
                    <img
                        src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/312e1ebf-0b90-4707-84ad-139a1e788875" />
                </details>
                <details>
                    <summary>ALB 적용</summary>
                    <img
                        src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/9edde021-e632-46e1-904b-fe860ef464f8" />
                </details>
            </ul>
        </ul>
    </details>
    <details>
        <summary>
            <h3>메인 서버에서 API 통신과 체결을 동시에 담당하는 문제 (ver 2.0 ⇒ ver 3.0)</h3>
        </summary>
        <ul>
            <li>문제 상황</li>
            <ul>
                <li>
                    ver 2.0에서 소켓 서버를 분리하였으나, 많은 체결이 몰렸을 때 CPU에서 API 요청과 메인 처리를 둘 다 담당해야 하는 문제가 발생
                </li>
                <br>
                <details>
                    <summary>ver 0.0에서 100명의 유저가 500번의 요청을 처리할 때 실제로 504,Gateway Time-out 에러가 발생하여 사용자의 요청을 제대로 처리하지 못함
                    </summary>
                    <img
                        src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/0b878657-7923-4e1e-973c-5cc1aac0ab98" />
                </details>
                <details>
                    <summary>ver 0.0~ver 2.0 모두 전체적으로 응답 시간과 TPS가 낮게 나옴
                    </summary>
                    <img
                        src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/cb0f0f90-4d58-4fff-aa96-2084aff58958" />
                </details>
                <details>
                    <summary>부하 테스트 이후 그라파나를 이용한 모니터링 결과 CPU에 가해지는 부하가 무척 큰 것을 확인
                    </summary>
                    <img
                        src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/d5d8a302-1596-4b55-8535-ef30d6be3385" />
                </details>
            </ul>
            <br>
            <li>해결 방법</li>
            <ul>
                <li>
                    카프카 메시지 큐를 사용하여 메인 서버에서 체결을 진행하지 않고 주문의 내용을 직렬화 하여 메시지로 전달
                </li>
                <li>
                    체결 서버에서는 해당 메시지를 역직렬화 하여 체결을 진행
                </li>
                <br>
                <details>
                    <summary>서버 버전 2.0</summary>
                    <img
                        src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/312e1ebf-0b90-4707-84ad-139a1e788875" />
                </details>
                <details>
                    <summary>서버 버전 3.0</summary>
                    <img
                        src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/a48b8c3e-e7ca-4ddb-91bf-b296b1e6a759" />
                </details>
                <details>
                    <summary>버전 3.0 부하 테스트 결과 TPS와 평균 응답 시간이 크게 개선된 것을 확인</summary>
                    <img
                        src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/418a5ba0-ab2e-4527-a092-b132ab69c58b" />
                </details>
                <details>
                    <summary>버전 3.0 모니터링 결과 CPU의 부하가 크게 감소하는 것을 확인</summary>
                    <img
                        src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/b3ee6b36-832a-454a-9008-044d09eb7ebf" />
                </details>
            </ul>
        </ul>
    </details>
    <details>
        <summary>
            <h3>주문 체결 처리에 많은 시간을 소모하는 문제  (ver 3.0 ⇒ ver4.0)</h3>
        </summary>
        <ul>
            <li>문제 상황</li>
            <ul>
                <details>
                    <summary>주문 유효성 검증, 주문 생성 및 삭제, 주문 매칭, 주문 체결 처리를 체결 서버에서 전부 담당
                    </summary>
                    체결 함수 ver 1.0 아래의 과정이 모두 하나의 체결 서버에서 MySQL 트랜잭션으로 처리
                    <img
                        src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/9a4f578e-6743-4325-a13d-507b712acc49" />
                </details>
            </ul>
            <br>
            <li>해결 방법</li>
            <ul>
                <li>
                    매칭 서버에서 Redis를 이용하여 주문 유효성 검증 및 매칭 작업을 진행하고 , 그 결과를 메시지큐로 체결서버에 전달 체결 서버에서 받아 MySQL을 이용하여 주문을 체결
                </li>
                <li>
                    예상 효과
                    <ul>
                        <li>
                            단일 주문 처리 속도 향상
                        </li>
                        <br>
                        <details>
                            <summary>일을 분할하면서 전체 처리 시간 향상
                            </summary>
                            <img
                                src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/b9274299-5e91-41e1-8816-ac2c34dc0378" />
                        </details>
                    </ul>
                </li>
                <br>
                <details>
                    <summary>Redis의 string, hashset, sortedset의 자료구조를 이용하여 매칭 서버에서도 체결 서버의 MySQL DB와 같이 정보를 저장</summary>
                    <img
                        src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/19a5a3c5-eb38-4fab-9899-899591bce2f5" />
                </details>
                <details>
                    <summary>체결 서버의 처리 내용이 다시 매칭 서버에 영향을 끼치지 않도록 로직을 구성하여 정합성 유지</summary>
                    <img
                        src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/8d65ff00-6915-4698-bf38-1648a1c4f55f" />
                </details>
                <details>
                    <summary>서버 버전 3.0</summary>
                    <img
                        src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/a48b8c3e-e7ca-4ddb-91bf-b296b1e6a759" />
                </details>
                <details>
                    <summary>서버 버전 4.0</summary>
                    <img
                        src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/2f42db30-afdb-4d86-94f4-ec8a6b30c64d" />
                </details>
                <details>
                    <summary>개선 결과</summary>
                    <details>
                        <summary>단일 주문 처리 시간 비교</summary>
                        <img
                            src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/67c0b6a4-74b4-4c9c-bbb1-27f666276d96" />"
                    </details>
                    <details>
                        <summary>동시 주문 10000건의 총 처리 시간 비교</summary>
                        <img
                            src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/31ddacdd-2271-464e-bb0e-a0ab1494c5c9" />"
                    </details>
                </details>
            </ul>
        </ul>
    </details>
    <details>
        <summary>
            <h3>한개의 메인 서버에서 부하를 감당하는 문제 (ver 4.0 ⇒ ver 5.0)</h3>
        </summary>
        <ul>
            <li>문제 상황</li>
            <ul>
                <li>
                    많은 사용자의 API 요청이 하나의 EC2 인스턴스에서 처리
                </li>
                <details>
                    <summary>이로 인해 부하 테스트에서 특정 시간에 CPU에 과부하가 걸리는 것을 확인 (ver 4.0, 동시 주문 2만건 부하테스트)
                    </summary>
                    <img
                        src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/d9821130-48d5-46c1-be28-552743d35f8c" />
                </details>
            </ul>
            <br>
            <li>해결 방법</li>
            <ul>
                <li>
                    Main 서버에서 게임을 관리하는 파트를 분리하여 게임 서버를 만들고 Main 서버의 EC2 인스턴스를 3대로 늘림
                </li>
                <li>
                    ALB를 통해 대상 그룹에 메인 서버 인스턴스를 3개 추가하여 로드밸런싱을 진행
                </li>
                <br>
                <details>
                    <summary>서버 버전 4.0</summary>
                    <img
                        src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/2f42db30-afdb-4d86-94f4-ec8a6b30c64d" />
                </details>
                <details>
                    <summary>서버 버전 5.0</summary>
                    <img
                        src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/1ae6b805-102a-4fab-b6fb-3e20ac5a7e2c" />
                </details>
                <details>
                    <summary>ALB를 통해 main 인스턴스3개에 로드 밸런싱(라운드 로빈)</summary>
                    <img
                        src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/418c81d9-0681-48cb-b790-242e76f5be00" />
                </details>
                <details>
                    <summary>부하테스트 TPS와 평균 응답 시간이 크게 개선되는 것을 확인</summary>
                    <img
                        src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/ad5d82fa-48e4-450f-9fd8-973fb5197c37" />
                </details>
                <details>
                    <summary>부하테스트 결과 CPU의 리소스의 사용률이 감소하는 것을 확인(ver 5.0, 동시 주문 2만건 부하테스트)</summary>
                    <img
                        src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/534e604c-ab46-4411-8ce7-e2f39257cc07" />
                </details>
            </ul>
        </ul>
    </details>
    <details>
        <summary>
            <h3>능동적인 인스턴스 관리 부재와 블루-그린 배포로 인한 비용 문제 (ver 5.0 ⇒ ver final)</h3>
        </summary>
        <ul>
            <li>문제 상황</li>
            <ul>
                <li>
                    사용자의 요청에 관계 없이 고정된 EC2 인스턴스의 수가 변하지 않아 요청이 적을 때에는 리소스가 낭비되고, 요청이 많을 때에는 서버에 과도한 부하가 집중됨
                </li>
                <br>
                <details>
                    <summary>무중단 배포를 NIGNX를 이용한 블루-그린 배포를 진행하였는데, 이 과정에 하나의 메인 서버를 위해 3개의 EC2 인스턴스가 필요하여 비용 문제가 발생
                    </summary>
                    <img
                        src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/c56e0e98-3951-45c8-8ad2-94fb136d8e95" />
                </details>
            </ul>
            <br>
            <li>해결 방법</li>
            <ul>
                <li>
                    기존의 CD 과정에서 ECR에 이미지를 업로드 하였는데, 이를 이용하여 AWS에서 제공하는 컨테이너 오케스트레이션 서비스인 ECS를 이용하여 메인 서버의 증설 및 로드 밸런싱,
                    오토스케일링, 무중단 배포(롤링 배포)를 적용
                </li>
                <br>
                <details>
                    <summary>ECS로 생성된 EC2에 로드 밸런싱이 적용</summary>
                    <img
                        src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/3bc9d870-5312-4681-99b9-8bf8eb488604" />
                </details>
                <details>
                    <summary>CPU의 부하율에 따라 오토 스케일링 적용</summary>
                    테스트를 위해 CPU를 1%만 사용해도 확장하도록 변경
                    <img
                        src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/5256ff4e-8500-43dd-b4eb-061ae246405f" />
                    ECS 태스크 확인 결과 태스크가 5개로 추가 된 것을 확인
                    <img
                        src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/7edeb878-6567-4973-9e91-47638a7d1f73" />
                    로드밸런서에도 제대로 반영이 되는 것을 확인
                    <img
                        src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/aeef0b63-6e5d-4c38-9510-c38734c66c8f" />
                </details>
                <details>
                    <summary>기존 그린-블루 배포에서 롤링 배포로 전환</summary>
                    <br>
                    <details>
                        <summary>
                            실제 롤링 배포가 적용되는 모습
                        </summary>
                        코드 업데이트 이후 새로운 배포가 활성화
                        <img
                            src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/9bf0ff9d-f186-41c4-9967-13f6981a430d" />
                        기존의 EC2 인스턴스를 하나씩 대체하는 것을 확인
                        <img
                            src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/81195e39-0166-43b4-ac63-5ab35049d661" />
                        모든 배포가 완료되고 기존 버전이 Draining 되는 모습
                        <img
                            src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/dde002d7-1d40-4b79-a384-46e7b9ecf6e7" />
                    </details>
                </details>
            </ul>
        </ul>
    </details>
</details>

<details>
    <summary>
        <h2>🔧장애 대응</h2>
    </summary>
    <details>
        <summary>
            <h2>카프카에서 문제가 발생 시</h2>
        </summary>
        <ul>
            <li>만일 하나의 브로커에 장애가 생겨 역할을 못하게 된다면 서버 자체를 사용할 수 없게 됨</li>
            <li>그렇기 때문에 카프카의 브로커를 3대로 구축하여 하나의 브로커에 장애가 생겼을때 다른 브로커들이 해당 브로커의 역할을 대신해 처리</li>
            <li>시스템 전체가 중단되는 것을 방지하고 장애가 발생한 브로커 격리 가능</li>
            <img
                src="https://github.com/hh99-stock/Stocking_Backend/assets/143411145/f46f640e-d26f-420b-a4cf-e19875fbaaa0" />
        </ul>
    </details>
    <details>
        <summary>
            <h2>AWS RDS에서 문제가 발생 시</h2>
        </summary>
        <ul>
            <li>RDS의 muiti-AZ 배포 옵션을 사용해 RDS의 에러에 대비 가능</li>
            <li>multil-AZ 배포 옵션 사용시 RDS는 마스터 데이터베이스와 동기적으로 복제된 데이터베이스의 복제본을 다른 가용 영역에 생성</li>
            <li>마스터 데이터베이스에 장애 발생시 RDS가 자동으로 복제본을 마스터 데이터베이스로 승격해 마스터 데이터베이스에 문제가 발생하더라도 서비스를 계속 제공함</li>
        </ul>
    </details>
    <details>
        <summary>
            <h2>카프카 중복 메시지 방지</h2>
        </summary>
        <ul>
            <li>카프카에 중복 메시지가 들어가게 되면 중복된 메시지로 인해 동일한 데이터를 여러번 처리하거나 이벤트 순서를 무시하게 됨</li>
            <li>동일한 작업을 여러번 수행해도 결과가 동일하게 유지되는 특성인 멱등성을 이용해 중복 메시지를 방지 </li>
        </ul>
    </details>
</details>

<details>
    <summary>
        <h2>❓기타 트러블 슈팅(각종 버그들)</h2>
    </summary>
    <a
        href="https://www.notion.so/STOCKING-BROCHURE-ae607d3fdfbb4814bd7ca68939320177?pvs=4#0df8f56f1cda48a9ac4e3dc08c7a26ef">전체
        목록</a>
    <br>
    <br>
    <a
        href="https://www.notion.so/STOCKING-BROCHURE-ae607d3fdfbb4814bd7ca68939320177?pvs=4#e67e5466cab04c48bccf5709e3afc718">Transaction
        API error</a> <br>
    <br>
    <a
        href="https://www.notion.so/STOCKING-BROCHURE-ae607d3fdfbb4814bd7ca68939320177?pvs=4#4784964169804798be54ad033d883602">로컬
        메시지 큐에서 데이터가 순차적으로 처리되지 않는 에러</a> <br>
    <br>
    <a
        href="https://www.notion.so/STOCKING-BROCHURE-ae607d3fdfbb4814bd7ca68939320177?pvs=4#878944b46f0f406c835869fcbb4eebab">
        테스트 중 RDS 연결이 끊기는 오류</a> <br>
    <br>
    <a
        href="https://www.notion.so/STOCKING-BROCHURE-ae607d3fdfbb4814bd7ca68939320177?pvs=4#d104462f0cc14fcfb0029d100c342b4c">
        jmeter 로컬 테스트 중 발생한 오류</a> <br>
    <br>
    <a
        href="https://www.notion.so/STOCKING-BROCHURE-ae607d3fdfbb4814bd7ca68939320177?pvs=4#65a7ceac672740778c1c85cd31f12df5">새로고침을
        할때마다 연결되는 클라이언트가 늘어나는 에러</a> <br>
    <br>
    <a
        href="https://www.notion.so/STOCKING-BROCHURE-ae607d3fdfbb4814bd7ca68939320177?pvs=4#1b14e1967bf542c593b5db166d96a667">로컬에서
        elastic cache 접속시 timeout</a> <br>
    <br>
    <a
        href="https://www.notion.so/STOCKING-BROCHURE-ae607d3fdfbb4814bd7ca68939320177?pvs=4#77fd8cfa5fc5475db9bff5710b269990">메인/소켓
        서버 분리 이후 소켓 연결이 안되는 에러</a> <br>
    <br>
    <a
        href="https://www.notion.so/STOCKING-BROCHURE-ae607d3fdfbb4814bd7ca68939320177?pvs=4#d1df9047b3d642269ec954a0509028d9">EC2
        인스턴스에서 public IP를 탄력적 IP로 재할당 한 이후에 접속이 안되는 오류 </a> <br>
    <br>
    <a
        href="https://www.notion.so/STOCKING-BROCHURE-ae607d3fdfbb4814bd7ca68939320177?pvs=4#fd081f26746249a3af153e4e38535d6b">EC2에서
        배포된 메인서버가 소켓서버와 자동으로 연결이 종료되는 오류</a> <br>
    <br>
    <a
        href="https://www.notion.so/STOCKING-BROCHURE-ae607d3fdfbb4814bd7ca68939320177?pvs=4#14265dbe74404981bb1990ec814226b1">EC2에서
        Jmeter로 테스트 시 WARNING이 뜨는 오류</a> <br>
    <br>
    <a
        href="https://www.notion.so/STOCKING-BROCHURE-ae607d3fdfbb4814bd7ca68939320177?pvs=4#c7b6d65ad4c247d18c57aa63596e0253">배포
        이후 로컬에서 카프카 컨슈머가 동작하지 않는 오류</a> <br>
    <br>
    <a
        href="https://www.notion.so/STOCKING-BROCHURE-ae607d3fdfbb4814bd7ca68939320177?pvs=4#0e62b1e08b43442c80fb01312fdc2e82">채팅창
        관련 이슈</a> <br>
    <br>
    <a
        href="https://www.notion.so/STOCKING-BROCHURE-ae607d3fdfbb4814bd7ca68939320177?pvs=4#e8666331417745bf96c601d5520fe394">Kafka
        관련 이슈</a> <br>
    <br>
    <a
        href="https://www.notion.so/STOCKING-BROCHURE-ae607d3fdfbb4814bd7ca68939320177?pvs=4#611b92cdc6d04702b7473bbdf07eed79">웹소켓
        연결 실패</a> <br>
    <br>
</details>
